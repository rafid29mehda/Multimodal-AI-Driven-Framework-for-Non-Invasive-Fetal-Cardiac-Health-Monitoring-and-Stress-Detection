# -*- coding: utf-8 -*-
"""NInFEA dataset project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PCFNILKxi6cq61W7p8J2i9ZRxeOmYH1R
"""

# Complete NInFEA Dataset Pipeline
# Description:
# - Downloads and extracts the NInFEA dataset.
# - Loads and preprocesses .bin (ECG) and .bmp (PWD) files.
# - Applies ICA to extract fECG, computes features, estimates FHR, trains SVM, explains with SHAP, and visualizes results.
# - Fixes header reading per ReadBinaryFile.m and implements PWD envelope extraction per envelope_extraction.m.
# - Processes a single file pair (s01.bin, s01.bmp) by default; includes optional multi-file processing.

# Step 1: Install dependencies
# Explanation: Install required Python libraries.
import os
import subprocess

# Install packages
subprocess.run(["pip", "install", "scipy", "numpy", "pandas", "matplotlib", "seaborn", "tensorflow", "scikit-learn", "wfdb", "opencv-python", "shap", "lime"])

import numpy as np
import scipy.signal
import cv2
import struct
import glob
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.decomposition import FastICA
from sklearn.svm import SVC
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
import shap
import tensorflow as tf

# Step 2: Download and extract NInFEA dataset
# Explanation: Downloads dataset from PhysioNet and extracts it.
if not os.path.exists("ninfea_data"):
    os.makedirs("ninfea_data")
    subprocess.run(["wget", "-r", "-N", "-c", "-np", "https://physionet.org/files/ninfea/1.0.0/", "-P", "ninfea_data"])
    subprocess.run(["unzip", "ninfea_data/physionet.org/files/ninfea/1.0.0/ninfea-1.0.0.zip", "-d", "ninfea_data"])

# Verify files
print("Listing .bin files:")
subprocess.run(["ls", "-l", "ninfea_data/bin_format_ecg_and_respiration"])
print("Listing .bmp files:")
subprocess.run(["ls", "-l", "ninfea_data/pwd_images"])

# Step 3: Define functions for loading and preprocessing
# Function to read .bin file (based on ReadBinaryFile.m)
def read_bin_file(file_path):
    with open(file_path, 'rb') as f:
        header = f.read(24)  # 24 bytes: 3 doubles
        if len(header) != 24:
            raise ValueError(f"Incomplete header in {file_path}: got {len(header)} bytes, expected 24")

        # Unpack header: all doubles, little-endian
        fs, n_channels, n_samples = struct.unpack('<ddd', header)
        print(f"Raw header bytes: {header.hex()}")

        # Validate header
        if abs(n_channels - 34.0) > 0.1:
            raise ValueError(f"Expected 34 channels, got {n_channels}")
        if abs(fs - 2048.0) > 0.1:
            raise ValueError(f"Expected sampling frequency 2048 Hz, got {fs}")
        n_samples = int(n_samples)
        if n_samples < 15360 or n_samples > 245760:  # 7.5–119.8 s
            raise ValueError(f"Invalid n_samples: {n_samples}. Expected 15360–245760")

        # Calculate expected data size
        expected_size = n_samples * 34
        f.seek(0, 2)
        file_size = f.tell()
        data_size = (file_size - 24) // 8
        if data_size != expected_size:
            raise ValueError(f"Data size mismatch: expected {expected_size} samples, got {data_size}")

        # Read data
        f.seek(24)
        data = np.fromfile(f, dtype=np.float64).reshape(n_samples, 34)
        print(f"Loaded {file_path}: fs={fs} Hz, n_channels={n_channels}, n_samples={n_samples}")

    return data, fs

# Function to extract PWD envelopes (simplified from envelope_extraction.m)
def extract_pwd_envelope(image):
    if len(image.shape) == 3:
        image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    row_sums = np.sum(image, axis=1)
    ascissa = np.where(row_sums == 255 * image.shape[1])[0]
    if len(ascissa) > 0:
        image[ascissa, :] = 0

    _, binary = cv2.threshold(image, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
    ascissa = ascissa[0] if len(ascissa) > 0 else image.shape[0] // 2
    up = binary[:ascissa, :]
    down = binary[ascissa:, :]

    x_up = []
    x_down = []
    for j in range(binary.shape[1]):
        up_col = up[:, j]
        down_col = down[:, j]
        up_indices = np.where(up_col == 1)[0]
        down_indices = np.where(down_col == 1)[0]
        x_up.append(ascissa - up_indices[0] if len(up_indices) > 0 else ascissa)
        x_down.append(-down_indices[-1] if len(down_indices) > 0 else 0)

    x_up = np.array(x_up)
    x_down = np.array(x_down)
    x_up = scipy.signal.savgol_filter(x_up, window_length=51, polyorder=3)
    x_down = scipy.signal.savgol_filter(x_down, window_length=51, polyorder=3)

    return x_up, x_down

# Step 3: Load and preprocess single file
# Explanation: Process one .bin and .bmp file pair.
bin_path = 'ninfea_data/bin_format_ecg_and_respiration/s01.bin'  # Update if needed
pwd_path = 'ninfea_data/pwd_images/s01.bmp'  # Update if needed

if not os.path.exists(bin_path) or not os.path.exists(pwd_path):
    raise FileNotFoundError("Files not found. Run '!ls ninfea_data/bin_format_ecg_and_respiration' and '!ls ninfea_data/pwd_images' to check available files.")

# Load data
data, fs = read_bin_file(bin_path)
fECG = data[:, :24]  # Channels 1–24
maternal_ECG = data[:, 24:27]  # Channels 25–27
respiration = data[:, 31]  # Channel 32

# Preprocess fECG
fECG = (fECG - np.mean(fECG, axis=0)) / np.std(fECG, axis=0, ddof=1)
b, a = scipy.signal.butter(4, [0.5, 100], btype='bandpass', fs=fs)
fECG = scipy.signal.filtfilt(b, a, fECG, axis=0)

# Load PWD image
pwd_image = cv2.imread(pwd_path)
if pwd_image is None:
    raise ValueError(f"Failed to load PWD image: {pwd_path}")

# Extract PWD envelopes
x_up, x_down = extract_pwd_envelope(pwd_image)

# Print shapes
print("fECG shape:", fECG.shape)
print("Maternal ECG shape:", maternal_ECG.shape)
print("Respiration shape:", respiration.shape)
print("PWD upper envelope shape:", x_up.shape)

# Step 3 (Optional): Process multiple files
# Explanation: Uncomment to process all 60 files instead of single file.
"""
all_fECG = []
all_x_up = []
all_respiration = []

bin_files = glob.glob('ninfea_data/bin_format_ecg_and_respiration/*.bin')
for bin_file in bin_files:
    base_name = os.path.basename(bin_file).replace('.bin', '')
    bmp_file = f'ninfea_data/pwd_images/{base_name}.bmp'

    if not os.path.exists(bmp_file):
        print(f"Skipping {bin_file}: No matching .bmp file")
        continue

    try:
        data, fs = read_bin_file(bin_file)
        fECG = data[:, :24]
        respiration = data[:, 31]
        fECG = (fECG - np.mean(fECG, axis=0)) / np.std(fECG, axis=0, ddof=1)
        b, a = scipy.signal.butter(4, [0.5, 100], btype='bandpass', fs=fs)
        fECG = scipy.signal.filtfilt(b, a, fECG, axis=0)

        pwd_image = cv2.imread(bmp_file)
        if pwd_image is None:
            print(f"Skipping {bin_file}: Failed to load {bmp_file}")
            continue
        x_up, _ = extract_pwd_envelope(pwd_image)

        all_fECG.append(fECG)
        all_x_up.append(x_up)
        all_respiration.append(respiration)
        print(f"Processed {base_name}: fECG shape {fECG.shape}, PWD upper envelope shape {x_up.shape}")

    except Exception as e:
        print(f"Error processing {bin_file}: {str(e)}")
        continue

print(f"Total files processed: {len(all_fECG)}")
# For multi-file, update downstream steps to loop over all_fECG, all_x_up, etc.
"""

# Step 4: Extract fECG using ICA
# Explanation: Apply FastICA to isolate fECG, correlate with PWD upper envelope.
ica = FastICA(n_components=24, random_state=42)
ica_components = ica.fit_transform(fECG)
pwd_resampled = scipy.signal.resample(x_up, fECG.shape[0])
correlations = [np.corrcoef(ica_components[:, i], pwd_resampled)[0, 1] for i in range(ica_components.shape[1])]
fECG_component_idx = np.argmax(np.abs(correlations))
clean_fECG = ica_components[:, fECG_component_idx]
print("Clean fECG shape:", clean_fECG.shape)

# Step 5: Extract features
# Explanation: Compute RR intervals (fECG), AV intervals (PWD), and respiration variability.
r_peaks, _ = scipy.signal.find_peaks(clean_fECG, distance=int(fs*0.2))
rr_intervals = np.diff(r_peaks) / fs
rr_mean = np.mean(rr_intervals) if len(rr_intervals) > 0 else 0
rr_std = np.std(rr_intervals) if len(rr_intervals) > 0 else 0

pwd_peaks, _ = scipy.signal.find_peaks(x_up, distance=50)
av_intervals = np.diff(pwd_peaks) / 60  # PWD at 60 Hz
av_mean = np.mean(av_intervals) if len(av_intervals) > 0 else 0
av_std = np.std(av_intervals) if len(av_intervals) > 0 else 0

resp_std = np.std(respiration)
features = np.array([rr_mean, rr_std, av_mean, av_std, resp_std])
print("Extracted features:", features)

# Step 6: Estimate FHR
# Explanation: Compute FHR from fECG and PWD.
fhr_fecg = 60 / rr_mean if rr_mean != 0 else 0
fhr_pwd = 60 / av_mean if av_mean != 0 else 0
print(f"FHR (fECG): {fhr_fecg:.2f} BPM, FHR (PWD): {fhr_pwd:.2f} BPM")

# Step 7: SVM classification (placeholder labels)
# Explanation: Train SVM to classify normal vs. abnormal FHR (mock labels).
# Note: NInFEA lacks ground truth labels, so we simulate.
labels = np.array([1 if fhr_fecg > 110 and fhr_fecg < 160 else 0])  # Normal: 110–160 BPM
X = features.reshape(1, -1)  # Single sample
if len(np.unique(labels)) > 1:  # Need multiple classes for SVM
    X_train, X_test, y_train, y_test = train_test_split(X, labels, test_size=0.2, random_state=42)
    svm = SVC(kernel='rbf', probability=True)
    svm.fit(X_train, y_train)
    y_pred = svm.predict(X_test)
    print("SVM accuracy:", accuracy_score(y_test, y_pred))
else:
    print("SVM skipped: Single sample, using mock label", labels[0])

# Step 8: SHAP explanations
# Explanation: Use SHAP to explain SVM feature importance.
explainer = shap.KernelExplainer(svm.predict_proba, X)
shap_values = explainer.shap_values(X)
shap.summary_plot(shap_values, X, feature_names=['RR Mean', 'RR Std', 'AV Mean', 'AV Std', 'Resp Std'])

# Step 9: Visualize results
# Explanation: Plot clean fECG, PWD upper envelope, and respiration.
t_fecg = np.arange(len(clean_fECG)) / fs
t_pwd = np.arange(len(x_up)) / 60
t_resp = np.arange(len(respiration)) / fs

plt.figure(figsize=(12, 8))
plt.subplot(3, 1, 1)
plt.plot(t_fecg, clean_fECG)
plt.title('Clean fECG')
plt.xlabel('Time (s)')
plt.ylabel('Amplitude')

plt.subplot(3, 1, 2)
plt.plot(t_pwd, x_up)
plt.title('PWD Upper Envelope')
plt.xlabel('Time (s)')
plt.ylabel('Amplitude')

plt.subplot(3, 1, 3)
plt.plot(t_resp, respiration)
plt.title('Maternal Respiration')
plt.xlabel('Time (s)')
plt.ylabel('Amplitude')

plt.tight_layout()
plt.show()

# Step 10: Save results
# Explanation: Save features and FHR estimates to CSV.
results = pd.DataFrame({
    'File': [os.path.basename(bin_path)],
    'RR_Mean': [rr_mean],
    'RR_Std': [rr_std],
    'AV_Mean': [av_mean],
    'AV_Std': [av_std],
    'Resp_Std': [resp_std],
    'FHR_fECG': [fhr_fecg],
    'FHR_PWD': [fhr_pwd]
})
results.to_csv('ninfea_results.csv', index=False)
print("Results saved to ninfea_results.csv")



















